    /* let contour_len = shape.contours.len();

    let mut shape_selector = MTEdgeSelector::new();
    let mut inner_selector = MTEdgeSelector::new();
    let mut outer_selector = MTEdgeSelector::new();

    shape_selector.reset(p);
    inner_selector.reset(p);
    outer_selector.reset(p);

    for (selector, winding) in selectors.iter().zip(windings.iter()) {
        let dist = selector.distance();
        shape_selector.merge(selector);
        if *winding > 0 && dist.resolve() >= 0.0 {
            inner_selector.merge(selector);
        }
        if *winding < 0 && dist.resolve() <= 0.0 {
            outer_selector.merge(selector);
        }
    }

    let shape_distance = shape_selector.distance();
    let inner_distance = inner_selector.distance();
    let outer_distance = outer_selector.distance();

    let inner_scalar_distance = inner_distance.resolve();
    let outer_scalar_distance = inner_distance.resolve();

    let mut distance;

    let winding;
    if inner_scalar_distance >= 0.0 && inner_scalar_distance.abs() <= outer_scalar_distance.abs() {
        distance = inner_distance;
        winding = 1;
        for i in 0..contour_len {
            if windings[i] > 0 {
                let contour_distance = selectors[i].distance();
                let resolved = contour_distance.resolve();
                if resolved.abs() < outer_scalar_distance.abs() && resolved > distance.resolve() {
                    distance = contour_distance;
                }
            }
        }
    } else if outer_scalar_distance <= 0.0 && outer_scalar_distance.abs() < inner_scalar_distance.abs() {
        distance = outer_distance;
        winding = -1;
        for i in 0..contour_len {
            if windings[i] < 0 {
                let contour_distance = selectors[i].distance();
                let resolved = contour_distance.resolve();
                if resolved.abs() < inner_scalar_distance.abs() && resolved < distance.resolve() {
                    distance = contour_distance;
                }
            }
        }
    } else {
        return shape_distance;
    }

    for i in 0..contour_len {
        if windings[i] != winding {
            let contour_distance = selectors[i].distance();
            let resolved = contour_distance.resolve();
            if resolved * distance.resolve() >= 0.0 && resolved.abs() < distance.resolve().abs() {
                distance = contour_distance;
            }
        }
    }

    if distance.resolve() == shape_distance.resolve() {
        distance = shape_distance;
    }

    distance */
